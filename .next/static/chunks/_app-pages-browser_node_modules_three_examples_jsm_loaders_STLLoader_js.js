"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_three_examples_jsm_loaders_STLLoader_js"],{

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/loaders/STLLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/STLLoader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STLLoader: () => (/* binding */ STLLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n\n\n/**\n * A loader for the STL format, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files. The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n * - Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n * - There is perhaps some question as to how valid it is to always assume little-endian-ness.\n * - ASCII decoding assumes file is UTF-8.\n *\n * ```js\n * const loader = new STLLoader();\n * const geometry = await loader.loadAsync( './models/stl/slotted_disk.stl' )\n * scene.add( new THREE.Mesh( geometry ) );\n * ```\n * For binary STLs geometry might contain colors for vertices. To use it:\n * ```js\n * // use the same code to load STL as above\n * if ( geometry.hasColors ) {\n * \tmaterial = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );\n * }\n * const mesh = new THREE.Mesh( geometry, material );\n * ```\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * ```js\n * const materials = [];\n * const nGeometryGroups = geometry.groups.length;\n *\n * for ( let i = 0; i < nGeometryGroups; i ++ ) {\n * \tconst material = new THREE.MeshPhongMaterial( { color: colorMap[ i ], wireframe: false } );\n * \tmaterials.push( material );\n * }\n *\n * const mesh = new THREE.Mesh(geometry, materials);\n * ```\n *\n * @augments Loader\n * @three_import import { STLLoader } from 'three/addons/loaders/STLLoader.js';\n */\nclass STLLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\t/**\n\t * Constructs a new STL loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded STL asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given STL data and returns the resulting geometry.\n\t *\n\t * @param {ArrayBuffer} data - The raw STL data as an array buffer.\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tconst n_faces = reader.getUint32( 80, true );\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst faces = reader.getUint32( 80, true );\n\n\t\t\tlet r, g, b, hasColors = false, colors;\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst dataOffset = 84;\n\t\t\tconst faceLength = 12 * 4 + 2;\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\t\tconst start = dataOffset + face * faceLength;\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst vertexstart = start + i * 12;\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolor.setRGB( r, g, b, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace );\n\n\t\t\t\t\t\tcolors[ componentIdx ] = color.r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = color.g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tconst patternName = /solid\\s(.+)/;\n\t\t\tlet faceCounter = 0;\n\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst groupNames = [];\n\n\t\t\tconst normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\tlet result;\n\n\t\t\tlet groupCount = 0;\n\t\t\tlet startVertex = 0;\n\t\t\tlet endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tconst solid = result[ 0 ];\n\n\t\t\t\tconst name = ( result = patternName.exec( solid ) ) !== null ? result[ 1 ] : '';\n\t\t\t\tgroupNames.push( name );\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\t\tconst text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst start = startVertex;\n\t\t\t\tconst count = endVertex - startVertex;\n\n\t\t\t\tgeometry.userData.groupNames = groupNames;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn new TextDecoder().decode( buffer );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tconst binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9TVExMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFTZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4Q0FBOEM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsb0RBQW9ELHlDQUF5QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0Esd0JBQXdCLHlDQUFNOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksMEJBQTBCO0FBQ3RDLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDZDQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLFNBQVM7O0FBRS9COztBQUVBOztBQUVBOztBQUVBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGlEQUFjOztBQUV0QztBQUNBOztBQUVBLHFCQUFxQix3Q0FBSzs7QUFFMUIsdUJBQXVCLGNBQWM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsUUFBUTs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QixpREFBYzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxrREFBZTtBQUN6RCx3Q0FBd0Msa0RBQWU7O0FBRXZEOztBQUVBLHdDQUF3QyxrREFBZTtBQUN2RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixpREFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQ0FBTzs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLHlEQUFzQjtBQUNoRSx3Q0FBd0MseURBQXNCOztBQUU5RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBbUI7O0FBRXhDLHdEQUF3RDs7QUFFeEQ7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hc2hlcmRlbG1hbi9EZXNrdG9wL0FzaC1uZXcvbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1NUTExvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckdlb21ldHJ5LFxuXHRDb2xvcixcblx0RmlsZUxvYWRlcixcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0TG9hZGVyLFxuXHRWZWN0b3IzLFxuXHRTUkdCQ29sb3JTcGFjZVxufSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogQSBsb2FkZXIgZm9yIHRoZSBTVEwgZm9ybWF0LCBhcyBjcmVhdGVkIGJ5IFNvbGlkd29ya3MgYW5kIG90aGVyIENBRCBwcm9ncmFtcy5cbiAqXG4gKiBTdXBwb3J0cyBib3RoIGJpbmFyeSBhbmQgQVNDSUkgZW5jb2RlZCBmaWxlcy4gVGhlIGxvYWRlciByZXR1cm5zIGEgbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5LlxuICpcbiAqIExpbWl0YXRpb25zOlxuICogLSBCaW5hcnkgZGVjb2Rpbmcgc3VwcG9ydHMgXCJNYWdpY3NcIiBjb2xvciBmb3JtYXQgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1RMXyhmaWxlX2Zvcm1hdCkjQ29sb3JfaW5fYmluYXJ5X1NUTCkuXG4gKiAtIFRoZXJlIGlzIHBlcmhhcHMgc29tZSBxdWVzdGlvbiBhcyB0byBob3cgdmFsaWQgaXQgaXMgdG8gYWx3YXlzIGFzc3VtZSBsaXR0bGUtZW5kaWFuLW5lc3MuXG4gKiAtIEFTQ0lJIGRlY29kaW5nIGFzc3VtZXMgZmlsZSBpcyBVVEYtOC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbG9hZGVyID0gbmV3IFNUTExvYWRlcigpO1xuICogY29uc3QgZ2VvbWV0cnkgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCAnLi9tb2RlbHMvc3RsL3Nsb3R0ZWRfZGlzay5zdGwnIClcbiAqIHNjZW5lLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5ICkgKTtcbiAqIGBgYFxuICogRm9yIGJpbmFyeSBTVExzIGdlb21ldHJ5IG1pZ2h0IGNvbnRhaW4gY29sb3JzIGZvciB2ZXJ0aWNlcy4gVG8gdXNlIGl0OlxuICogYGBganNcbiAqIC8vIHVzZSB0aGUgc2FtZSBjb2RlIHRvIGxvYWQgU1RMIGFzIGFib3ZlXG4gKiBpZiAoIGdlb21ldHJ5Lmhhc0NvbG9ycyApIHtcbiAqIFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoIHsgb3BhY2l0eTogZ2VvbWV0cnkuYWxwaGEsIHZlcnRleENvbG9yczogdHJ1ZSB9ICk7XG4gKiB9XG4gKiBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogYGBgXG4gKiBGb3IgQVNDSUkgU1RMcyBjb250YWluaW5nIG11bHRpcGxlIHNvbGlkcywgZWFjaCBzb2xpZCBpcyBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCBncm91cC5cbiAqIEdyb3VwcyBjYW4gYmUgdXNlZCB0byBhc3NpZ24gYSBkaWZmZXJlbnQgY29sb3IgYnkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgbWF0ZXJpYWxzIHdpdGggdGhlIHNhbWUgbGVuZ3RoIG9mXG4gKiBnZW9tZXRyeS5ncm91cHMgYW5kIHBhc3NpbmcgaXQgdG8gdGhlIE1lc2ggY29uc3RydWN0b3I6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1hdGVyaWFscyA9IFtdO1xuICogY29uc3Qgbkdlb21ldHJ5R3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzLmxlbmd0aDtcbiAqXG4gKiBmb3IgKCBsZXQgaSA9IDA7IGkgPCBuR2VvbWV0cnlHcm91cHM7IGkgKysgKSB7XG4gKiBcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvck1hcFsgaSBdLCB3aXJlZnJhbWU6IGZhbHNlIH0gKTtcbiAqIFx0bWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XG4gKiB9XG4gKlxuICogY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbHMpO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExvYWRlclxuICogQHRocmVlX2ltcG9ydCBpbXBvcnQgeyBTVExMb2FkZXIgfSBmcm9tICd0aHJlZS9hZGRvbnMvbG9hZGVycy9TVExMb2FkZXIuanMnO1xuICovXG5jbGFzcyBTVExMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFNUTCBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbG9hZGluZyBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIHBhc3NlcyB0aGUgbG9hZGVkIFNUTCBhc3NldFxuXHQgKiB0byB0aGUgYG9uTG9hZCgpYCBjYWxsYmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBwYXRoL1VSTCBvZiB0aGUgZmlsZSB0byBiZSBsb2FkZWQuIFRoaXMgY2FuIGFsc28gYmUgYSBkYXRhIFVSSS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihCdWZmZXJHZW9tZXRyeSl9IG9uTG9hZCAtIEV4ZWN1dGVkIHdoZW4gdGhlIGxvYWRpbmcgcHJvY2VzcyBoYXMgYmVlbiBmaW5pc2hlZC5cblx0ICogQHBhcmFtIHtvblByb2dyZXNzQ2FsbGJhY2t9IG9uUHJvZ3Jlc3MgLSBFeGVjdXRlZCB3aGlsZSB0aGUgbG9hZGluZyBpcyBpbiBwcm9ncmVzcy5cblx0ICogQHBhcmFtIHtvbkVycm9yQ2FsbGJhY2t9IG9uRXJyb3IgLSBFeGVjdXRlZCB3aGVuIGVycm9ycyBvY2N1ci5cblx0ICovXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gU1RMIGRhdGEgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSAtIFRoZSByYXcgU1RMIGRhdGEgYXMgYW4gYXJyYXkgYnVmZmVyLlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX0gVGhlIHBhcnNlZCBnZW9tZXRyeS5cblx0ICovXG5cdHBhcnNlKCBkYXRhICkge1xuXG5cdFx0ZnVuY3Rpb24gaXNCaW5hcnkoIGRhdGEgKSB7XG5cblx0XHRcdGNvbnN0IHJlYWRlciA9IG5ldyBEYXRhVmlldyggZGF0YSApO1xuXHRcdFx0Y29uc3QgZmFjZV9zaXplID0gKCAzMiAvIDggKiAzICkgKyAoICggMzIgLyA4ICogMyApICogMyApICsgKCAxNiAvIDggKTtcblx0XHRcdGNvbnN0IG5fZmFjZXMgPSByZWFkZXIuZ2V0VWludDMyKCA4MCwgdHJ1ZSApO1xuXHRcdFx0Y29uc3QgZXhwZWN0ID0gODAgKyAoIDMyIC8gOCApICsgKCBuX2ZhY2VzICogZmFjZV9zaXplICk7XG5cblx0XHRcdGlmICggZXhwZWN0ID09PSByZWFkZXIuYnl0ZUxlbmd0aCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbiBBU0NJSSBTVEwgZGF0YSBtdXN0IGJlZ2luIHdpdGggJ3NvbGlkICcgYXMgdGhlIGZpcnN0IHNpeCBieXRlcy5cblx0XHRcdC8vIEhvd2V2ZXIsIEFTQ0lJIFNUTHMgbGFja2luZyB0aGUgU1BBQ0UgYWZ0ZXIgdGhlICdkJyBhcmUga25vd24gdG8gYmVcblx0XHRcdC8vIHBsZW50aWZ1bC4gIFNvLCBjaGVjayB0aGUgZmlyc3QgNSBieXRlcyBmb3IgJ3NvbGlkJy5cblxuXHRcdFx0Ly8gU2V2ZXJhbCBlbmNvZGluZ3MsIHN1Y2ggYXMgVVRGLTgsIHByZWNlZGUgdGhlIHRleHQgd2l0aCB1cCB0byA1IGJ5dGVzOlxuXHRcdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI0J5dGVfb3JkZXJfbWFya3NfYnlfZW5jb2Rpbmdcblx0XHRcdC8vIFNlYXJjaCBmb3IgXCJzb2xpZFwiIHRvIHN0YXJ0IGFueXdoZXJlIGFmdGVyIHRob3NlIHByZWZpeGVzLlxuXG5cdFx0XHQvLyBVUy1BU0NJSSBvcmRpbmFsIHZhbHVlcyBmb3IgJ3MnLCAnbycsICdsJywgJ2knLCAnZCdcblxuXHRcdFx0Y29uc3Qgc29saWQgPSBbIDExNSwgMTExLCAxMDgsIDEwNSwgMTAwIF07XG5cblx0XHRcdGZvciAoIGxldCBvZmYgPSAwOyBvZmYgPCA1OyBvZmYgKysgKSB7XG5cblx0XHRcdFx0Ly8gSWYgXCJzb2xpZFwiIHRleHQgaXMgbWF0Y2hlZCB0byB0aGUgY3VycmVudCBvZmZzZXQsIGRlY2xhcmUgaXQgdG8gYmUgYW4gQVNDSUkgU1RMLlxuXG5cdFx0XHRcdGlmICggbWF0Y2hEYXRhVmlld0F0KCBzb2xpZCwgcmVhZGVyLCBvZmYgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3VsZG4ndCBmaW5kIFwic29saWRcIiB0ZXh0IGF0IHRoZSBiZWdpbm5pbmc7IGl0IGlzIGJpbmFyeSBTVEwuXG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWF0Y2hEYXRhVmlld0F0KCBxdWVyeSwgcmVhZGVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdC8vIENoZWNrIGlmIGVhY2ggYnl0ZSBpbiBxdWVyeSBtYXRjaGVzIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGUgZnJvbSB0aGUgY3VycmVudCBvZmZzZXRcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcXVlcnlbIGkgXSAhPT0gcmVhZGVyLmdldFVpbnQ4KCBvZmZzZXQgKyBpICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUJpbmFyeSggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IERhdGFWaWV3KCBkYXRhICk7XG5cdFx0XHRjb25zdCBmYWNlcyA9IHJlYWRlci5nZXRVaW50MzIoIDgwLCB0cnVlICk7XG5cblx0XHRcdGxldCByLCBnLCBiLCBoYXNDb2xvcnMgPSBmYWxzZSwgY29sb3JzO1xuXHRcdFx0bGV0IGRlZmF1bHRSLCBkZWZhdWx0RywgZGVmYXVsdEIsIGFscGhhO1xuXG5cdFx0XHQvLyBwcm9jZXNzIFNUTCBoZWFkZXJcblx0XHRcdC8vIGNoZWNrIGZvciBkZWZhdWx0IGNvbG9yIGluIGhlYWRlciAoXCJDT0xPUj1yZ2JhXCIgc2VxdWVuY2UpLlxuXG5cdFx0XHRmb3IgKCBsZXQgaW5kZXggPSAwOyBpbmRleCA8IDgwIC0gMTA7IGluZGV4ICsrICkge1xuXG5cdFx0XHRcdGlmICggKCByZWFkZXIuZ2V0VWludDMyKCBpbmRleCwgZmFsc2UgKSA9PSAweDQzNEY0QzRGIC8qQ09MTyovICkgJiZcblx0XHRcdFx0XHQoIHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA0ICkgPT0gMHg1MiAvKidSJyovICkgJiZcblx0XHRcdFx0XHQoIHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA1ICkgPT0gMHgzRCAvKic9JyovICkgKSB7XG5cblx0XHRcdFx0XHRoYXNDb2xvcnMgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzICogMyAqIDMgKTtcblxuXHRcdFx0XHRcdGRlZmF1bHRSID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDYgKSAvIDI1NTtcblx0XHRcdFx0XHRkZWZhdWx0RyA9IHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA3ICkgLyAyNTU7XG5cdFx0XHRcdFx0ZGVmYXVsdEIgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgOCApIC8gMjU1O1xuXHRcdFx0XHRcdGFscGhhID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDkgKSAvIDI1NTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGF0YU9mZnNldCA9IDg0O1xuXHRcdFx0Y29uc3QgZmFjZUxlbmd0aCA9IDEyICogNCArIDI7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZXMgKiAzICogMyApO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzICogMyAqIDMgKTtcblxuXHRcdFx0Y29uc3QgY29sb3IgPSBuZXcgQ29sb3IoKTtcblxuXHRcdFx0Zm9yICggbGV0IGZhY2UgPSAwOyBmYWNlIDwgZmFjZXM7IGZhY2UgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBkYXRhT2Zmc2V0ICsgZmFjZSAqIGZhY2VMZW5ndGg7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbFggPSByZWFkZXIuZ2V0RmxvYXQzMiggc3RhcnQsIHRydWUgKTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsWSA9IHJlYWRlci5nZXRGbG9hdDMyKCBzdGFydCArIDQsIHRydWUgKTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsWiA9IHJlYWRlci5nZXRGbG9hdDMyKCBzdGFydCArIDgsIHRydWUgKTtcblxuXHRcdFx0XHRpZiAoIGhhc0NvbG9ycyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBhY2tlZENvbG9yID0gcmVhZGVyLmdldFVpbnQxNiggc3RhcnQgKyA0OCwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCAoIHBhY2tlZENvbG9yICYgMHg4MDAwICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGZhY2V0IGhhcyBpdHMgb3duIHVuaXF1ZSBjb2xvclxuXG5cdFx0XHRcdFx0XHRyID0gKCBwYWNrZWRDb2xvciAmIDB4MUYgKSAvIDMxO1xuXHRcdFx0XHRcdFx0ZyA9ICggKCBwYWNrZWRDb2xvciA+PiA1ICkgJiAweDFGICkgLyAzMTtcblx0XHRcdFx0XHRcdGIgPSAoICggcGFja2VkQ29sb3IgPj4gMTAgKSAmIDB4MUYgKSAvIDMxO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ciA9IGRlZmF1bHRSO1xuXHRcdFx0XHRcdFx0ZyA9IGRlZmF1bHRHO1xuXHRcdFx0XHRcdFx0YiA9IGRlZmF1bHRCO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnRleHN0YXJ0ID0gc3RhcnQgKyBpICogMTI7XG5cdFx0XHRcdFx0Y29uc3QgY29tcG9uZW50SWR4ID0gKCBmYWNlICogMyAqIDMgKSArICggKCBpIC0gMSApICogMyApO1xuXG5cdFx0XHRcdFx0dmVydGljZXNbIGNvbXBvbmVudElkeCBdID0gcmVhZGVyLmdldEZsb2F0MzIoIHZlcnRleHN0YXJ0LCB0cnVlICk7XG5cdFx0XHRcdFx0dmVydGljZXNbIGNvbXBvbmVudElkeCArIDEgXSA9IHJlYWRlci5nZXRGbG9hdDMyKCB2ZXJ0ZXhzdGFydCArIDQsIHRydWUgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgY29tcG9uZW50SWR4ICsgMiBdID0gcmVhZGVyLmdldEZsb2F0MzIoIHZlcnRleHN0YXJ0ICsgOCwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgY29tcG9uZW50SWR4IF0gPSBub3JtYWxYO1xuXHRcdFx0XHRcdG5vcm1hbHNbIGNvbXBvbmVudElkeCArIDEgXSA9IG5vcm1hbFk7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY29tcG9uZW50SWR4ICsgMiBdID0gbm9ybWFsWjtcblxuXHRcdFx0XHRcdGlmICggaGFzQ29sb3JzICkge1xuXG5cdFx0XHRcdFx0XHRjb2xvci5zZXRSR0IoIHIsIGcsIGIsIFNSR0JDb2xvclNwYWNlICk7XG5cblx0XHRcdFx0XHRcdGNvbG9yc1sgY29tcG9uZW50SWR4IF0gPSBjb2xvci5yO1xuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggKyAxIF0gPSBjb2xvci5nO1xuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggKyAyIF0gPSBjb2xvci5iO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRpZiAoIGhhc0NvbG9ycyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cdFx0XHRcdGdlb21ldHJ5Lmhhc0NvbG9ycyA9IHRydWU7XG5cdFx0XHRcdGdlb21ldHJ5LmFscGhhID0gYWxwaGE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSSggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGNvbnN0IHBhdHRlcm5Tb2xpZCA9IC9zb2xpZChbXFxzXFxTXSo/KWVuZHNvbGlkL2c7XG5cdFx0XHRjb25zdCBwYXR0ZXJuRmFjZSA9IC9mYWNldChbXFxzXFxTXSo/KWVuZGZhY2V0L2c7XG5cdFx0XHRjb25zdCBwYXR0ZXJuTmFtZSA9IC9zb2xpZFxccyguKykvO1xuXHRcdFx0bGV0IGZhY2VDb3VudGVyID0gMDtcblxuXHRcdFx0Y29uc3QgcGF0dGVybkZsb2F0ID0gL1tcXHNdKyhbKy1dPyg/OlxcZCopKD86XFwuXFxkKik/KD86W2VFXVsrLV0/XFxkKyk/KS8uc291cmNlO1xuXHRcdFx0Y29uc3QgcGF0dGVyblZlcnRleCA9IG5ldyBSZWdFeHAoICd2ZXJ0ZXgnICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0LCAnZycgKTtcblx0XHRcdGNvbnN0IHBhdHRlcm5Ob3JtYWwgPSBuZXcgUmVnRXhwKCAnbm9ybWFsJyArIHBhdHRlcm5GbG9hdCArIHBhdHRlcm5GbG9hdCArIHBhdHRlcm5GbG9hdCwgJ2cnICk7XG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCBncm91cE5hbWVzID0gW107XG5cblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGxldCByZXN1bHQ7XG5cblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblx0XHRcdGxldCBzdGFydFZlcnRleCA9IDA7XG5cdFx0XHRsZXQgZW5kVmVydGV4ID0gMDtcblxuXHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5Tb2xpZC5leGVjKCBkYXRhICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRzdGFydFZlcnRleCA9IGVuZFZlcnRleDtcblxuXHRcdFx0XHRjb25zdCBzb2xpZCA9IHJlc3VsdFsgMCBdO1xuXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSAoIHJlc3VsdCA9IHBhdHRlcm5OYW1lLmV4ZWMoIHNvbGlkICkgKSAhPT0gbnVsbCA/IHJlc3VsdFsgMSBdIDogJyc7XG5cdFx0XHRcdGdyb3VwTmFtZXMucHVzaCggbmFtZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuRmFjZS5leGVjKCBzb2xpZCApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRsZXQgdmVydGV4Q291bnRQZXJGYWNlID0gMDtcblx0XHRcdFx0XHRsZXQgbm9ybWFsQ291bnRQZXJGYWNlID0gMDtcblxuXHRcdFx0XHRcdGNvbnN0IHRleHQgPSByZXN1bHRbIDAgXTtcblxuXHRcdFx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuTm9ybWFsLmV4ZWMoIHRleHQgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWwueCA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICk7XG5cdFx0XHRcdFx0XHRub3JtYWwueSA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICk7XG5cdFx0XHRcdFx0XHRub3JtYWwueiA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMyBdICk7XG5cdFx0XHRcdFx0XHRub3JtYWxDb3VudFBlckZhY2UgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0dGVyblZlcnRleC5leGVjKCB0ZXh0ICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggcGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKSwgcGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKSwgcGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKSApO1xuXHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXhDb3VudFBlckZhY2UgKys7XG5cdFx0XHRcdFx0XHRlbmRWZXJ0ZXggKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBldmVyeSBmYWNlIGhhdmUgdG8gb3duIE9ORSB2YWxpZCBub3JtYWxcblxuXHRcdFx0XHRcdGlmICggbm9ybWFsQ291bnRQZXJGYWNlICE9PSAxICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU1RMTG9hZGVyOiBTb21ldGhpbmcgaXNuXFwndCByaWdodCB3aXRoIHRoZSBub3JtYWwgb2YgZmFjZSBudW1iZXIgJyArIGZhY2VDb3VudGVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlYWNoIGZhY2UgaGF2ZSB0byBvd24gVEhSRUUgdmFsaWQgdmVydGljZXNcblxuXHRcdFx0XHRcdGlmICggdmVydGV4Q291bnRQZXJGYWNlICE9PSAzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU1RMTG9hZGVyOiBTb21ldGhpbmcgaXNuXFwndCByaWdodCB3aXRoIHRoZSB2ZXJ0aWNlcyBvZiBmYWNlIG51bWJlciAnICsgZmFjZUNvdW50ZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZhY2VDb3VudGVyICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IHN0YXJ0VmVydGV4O1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGVuZFZlcnRleCAtIHN0YXJ0VmVydGV4O1xuXG5cdFx0XHRcdGdlb21ldHJ5LnVzZXJEYXRhLmdyb3VwTmFtZXMgPSBncm91cE5hbWVzO1xuXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCBzdGFydCwgY291bnQsIGdyb3VwQ291bnQgKTtcblx0XHRcdFx0Z3JvdXBDb3VudCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuc3VyZVN0cmluZyggYnVmZmVyICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBidWZmZXIgIT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbnN1cmVCaW5hcnkoIGJ1ZmZlciApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRjb25zdCBhcnJheV9idWZmZXIgPSBuZXcgVWludDhBcnJheSggYnVmZmVyLmxlbmd0aCApO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXlfYnVmZmVyWyBpIF0gPSBidWZmZXIuY2hhckNvZGVBdCggaSApICYgMHhmZjsgLy8gaW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW5cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5X2J1ZmZlci5idWZmZXIgfHwgYXJyYXlfYnVmZmVyO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHN0YXJ0XG5cblx0XHRjb25zdCBiaW5EYXRhID0gZW5zdXJlQmluYXJ5KCBkYXRhICk7XG5cblx0XHRyZXR1cm4gaXNCaW5hcnkoIGJpbkRhdGEgKSA/IHBhcnNlQmluYXJ5KCBiaW5EYXRhICkgOiBwYXJzZUFTQ0lJKCBlbnN1cmVTdHJpbmcoIGRhdGEgKSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBTVExMb2FkZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/loaders/STLLoader.js\n"));

/***/ })

}]);